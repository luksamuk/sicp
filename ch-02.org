#+TITLE: Building Abstractions with Data
#+AUTHOR: Lucas S. Vieira
#+LANGUAGE: en-us
#+OPTIONS: toc:nil
#+STARTUP: latexpreview showeverything inlineimages
#+PROPERTY: header-args:scheme :cache yes :noweb strip-export :exports both

* Exercise 2.1

#+begin_src scheme
(define (make-rat n d)
  (if (negative? d)
      (make-rat (- n) (- d))
      (let ((g (gcd n d)))
        (cons (/ n g) (/ d g)))))
#+end_src

* Exercise 2.2

#+name: point_segment
#+begin_src scheme
;; Segments are pairs of points
(define (make-segment p1 p2)
  (cons p1 p2))

(define (start-segment s) (car s))

(define (end-segment s) (cdr s))


;; Points are pairs of numbers
(define (make-point x y)
  (cons x y))

(define (x-point p) (car p))

(define (y-point p) (cdr p))


;; Midpoint
(define (midpoint-segment s)
  (define (average a b)
    (/ (+ a b) 2))
  (let ((start (start-segment s))
        (end   (end-segment   s)))
    (make-point (average (x-point start) (x-point end))
                (average (y-point start) (y-point end)))))


;; Given by exercise
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ", ")
  (display (y-point p))
  (display ")"))
#+end_src

** Tests

#+begin_src scheme :results output
<<point_segment>>

(define x (make-point 0 0))
(define y (make-point 10 10))
(define s (make-segment x y))
(define z (midpoint-segment s))

(map print-point (list x y z))
#+end_src

#+RESULTS[cb8c430a29ba10547379b0319bbc4026877f8994]:
: 
: (0, 0)
: (10, 10)
: (5, 5)

* Exercise 2.3

*NOTE:* Reusing answers to Exercise 2.2.

** Representation 1

Two diagonal points.

#+name: repr_rect1
#+begin_src scheme
<<point_segment>>

(define (make-rect p1 p2)
  (cons p1 p2))

(define (rect-width r)
  (let ((fst (car r))
        (snd (cdr r)))
    (abs (- (y-point fst) (y-point snd)))))

(define (rect-height r)
  (let ((fst (car r))
        (snd (cdr r)))
    (abs (- (x-point fst) (x-point snd)))))
#+end_src

** Representation 2

Bottom-left point, width and height.

#+name: repr_rect2
#+begin_src scheme
<<point_segment>>

(define (make-rect p w h)
  (cons p (cons w h)))

(define (rect-width r)
  (car (cdr r)))

(define (rect-height r)
  (cdr (cdr r)))
#+end_src

** Area and perimeter

These functions should work with any of the above implementations.

#+name: rect_area_perimeter
#+begin_src scheme
(define (rect-perimeter r)
  (* 2 (+ (rect-width r)
          (rect-height r))))

(define (rect-area r)
  (* (rect-width r)
     (rect-height r)))
#+end_src

** Running tests

#+begin_src scheme :results output
<<repr_rect1>>
<<rect_area_perimeter>>

(define x (make-rect (make-point 0 0)
                     (make-point 10 10)))
(define y (make-rect (make-point 10 10)
                     (make-point 20 15)))

(map (lambda (r)
       (newline)
       (display "Perimeter: ")
       (display (rect-perimeter r))
       (display " Area: ")
       (display (rect-area r)))
     (list x y))
#+end_src

#+RESULTS[24e84c580f5db4840f1cc70947c6c8bc2cb49da5]:
: 
: Perimeter: 40 Area: 100
: Perimeter: 30 Area: 50

#+begin_src scheme :results output
<<repr_rect2>>
<<rect_area_perimeter>>

(define x (make-rect (make-point 0 0) 10 10))
(define y (make-rect (make-point 10 10) 10 5))

(map (lambda (r)
       (newline)
       (display "Perimeter: ")
       (display (rect-perimeter r))
       (display " Area: ")
       (display (rect-area r)))
     (list x y))
#+end_src

#+RESULTS[e6cfee049defec94b68749e016a7c949e0362672]:
: 
: Perimeter: 40 Area: 100
: Perimeter: 30 Area: 50
