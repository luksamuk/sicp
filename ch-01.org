#+DESCRIPTION: Answers for exercises of the book Structure and Interpretation of Computer Programs.
#+LANGUAGE: en-us
#+OPTIONS: toc:nil

[fn:ex1-7] This solution is still a problem for small numbers and needs to be revisited.


* Exercise 1.1
#+BEGIN_SRC text
  10 ;; => 10

  (+ 5 3 4) ;; => 12

  (- 9 1) ;; => 8

  (/ 6 2) ;; => 3

  (+ (* 2 4) (- 4 6)) ;; => 6

  (define a 3) ;; => a

  (define b (+ a 1)) ;; => b

  (+ a b (* a b)) ;; => 19

  (= a b) ;; => #f

  (if (and (> b a) (< b (* a b)))
      b
      a) ;; => 4

  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25)) ;; => 16

  (+ 2 (if (> b a) b a)) ;; => 6

  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1)) ;; => 16
#+END_SRC

* Exercise 1.2
#+BEGIN_SRC scheme
  (/ (+ 5 4 (- 2 3 (+ 6 (/ 4 5))))
     (* 3 (- 6 2) (- 2 7)))
#+END_SRC

* Exercise 1.3
#+BEGIN_SRC scheme
  (define (square-of-two-largest x y z)
    (cond ((> x y)
           (+ (* x x)
              (if (> y z)
                  (* y y)
                  (* z z))))
          (else
           (+ (* y y)
              (if (> x z)
                  (* x x)
                  (* z z))))))
#+END_SRC

* Exercise 1.4
The conditional inside the expression yields a different operation with respect to
the value of =b=. This operation is, then, applied to =a= and =b=.

* Exercise 1.5
When the interpreter uses applicative-order evaluation, the procedure yields correctly
the value =0=, since when evaluating the conditional contained in the body of the expression,
it only evaluates the predicate, finds it to be true, and then proceeds to yield the result
of the evaluation of the consequent. However, in normal-order evaluation, the interpreter
will proceed as expected until after the predicate evaluation; at this point, it will attempt
to evaluate not only the consequent, but also the alternative, which will force the program to
enter an infinite behaviour.

* Exercise 1.6
When Alyssa attempts to use this new implementation, the program will end up in an infinite loop.
Since =new-if= is implemented as a function, whenever it is called, it will attempt to evaluate
the predicate, the consequent and the alternative, before actually getting to the conditional
statement. This will result in the calling of =sqrt-iter=, even when the program is supposed to
stop.

* Exercise 1.7

=good-enough?=, as currently given, can easily be show to not work on very small or very large
numbers, since it uses a fixed number (=0.001=) as a way to determine if the difference is small
enough. This means that calculations such as

#+BEGIN_SRC scheme
  (sqrt 1000000)
  (sqrt 0.0000001)
#+END_SRC

will most likely take quite a while to catch up with their expected values, though their results
can be quicker to calculate through other means. [TODO: failure? I need to talk about it, these
statements might be wrong!]

We may, then, design a =square-root= procedure[fn:ex1-7] which takes the guess and watches how it evolves,
and then stop when the change is a very small fraction of the guess:

#+BEGIN_SRC scheme
  (define (good-enough? guess old-guess)
    (< (abs (- guess old-guess))
       (/ guess 10000)))

  (define (average x y)
    (/ (+ x y) 2))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (sqrt-iter guess old-guess x)
    (if (good-enough? guess old-guess)
        guess
        (sqrt-iter (improve guess x)
                   guess
                   x)))

  (define (sqrt x)
    (sqrt-iter 1.0 0.0 x))
#+END_SRC

* Exercise 1.8
In this example, we use the =good-enough?= algorithm from the previous exercise. The heavy
changes, when compared to the square root algorithm, happen on the =improve-cb= procedure.

#+BEGIN_SRC scheme
  ;; We borrow square from the book
  (define (square x)
    (* x x))


  (define (good-enough? guess old-guess)
    (< (abs (- guess old-guess))
       (/ guess 10000)))

  (define (improve-cb guess x)
    (/ (+ (/ x (square guess))
          (* 2 guess))
       3))

  (define (cbrt-iter guess old-guess x)
    (if (good-enough? guess old-guess)
        guess
        (cbrt-iter (improve-cb guess x)
                   guess
                   x)))

  (define (cbrt x)
    (cbrt-iter 1.0 0.0 x))
#+END_SRC

* Exercise 1.9
First method:
#+BEGIN_SRC text
  (+ 4 5)
  (inc (+ (dec 4) 5))
  (inc (+ 3 5))
  (inc (inc (+ (dec 3) 5)))
  (inc (inc (+ 2 5)))
  (inc (inc (inc (+ (dec 2) 5))))
  (inc (inc (inc (+ 1 5))))
  (inc (inc (inc (inc (+ (dec 1) 5)))))
  (inc (inc (inc (inc (+ 0 5)))))
  (inc (inc (inc (inc 5))))
  (inc (inc (inc 6)))
  (inc (inc 7))
  (inc 8)
  9
#+END_SRC
This is a linear recursive process.

Second method:
#+BEGIN_SRC text
  (+ 4 5)
  (+ (dec 4) (inc 5))
  (+ 3 6)
  (+ (dec 3) (inc 6))
  (+ 2 7)
  (+ (dec 2) (inc 7))
  (+ 1 8)
  (+ (dec 1) (inc 8))
  (+ 0 9)
  9
#+END_SRC
This is a linear iterative process.

* Exercise 1.10
For this exercise, instead of evaluating a linear recursive process by hand, I gave up and
had Chez Scheme evaluate the results for me.
#+BEGIN_SRC text
  (A 1 10) => 1024
  (A 2 4)  => 65536
  (A 3 3)  => 65536
#+END_SRC

Concise mathematical definitions:
#+BEGIN_SRC text
  (f n) => 2n
  (g n) => 2^n
  (h n) => 2^n²
  (k n) => 5n²
#+END_SRC

* Exercise 1.11
=f='s rules for reference:
#+BEGIN_SRC text
  f(n) = n                                 (for n < 3)
  f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3)  (for n >= 3)
#+END_SRC

Now we compute a procedure that calculates =f(n)= through an iterative process.
#+BEGIN_SRC scheme
  (define (f-iter n count back2 back1 curr)
    (cond ((= count n) curr)
          (else (f-iter n (1+ count) back1 curr
                        (+ curr
                           (* 2 back1)
                           (* 3 back2))))))

  (define (f n)
    (cond ((< n 3) n)
          (else (f-iter n 2 0 1 2))))

  ;; Recursive implementation, for comparision
  (define (f-recursive n)
    (cond ((< n 3) n)
          (else (+ (f-recursive (1- n))
                   (* 2 (f-recursive (- n 2)))
                   (* 3 (f-recursive (- n 3)))))))
#+END_SRC

* Exercise 1.12
This solution assumes base-0 and valid indexes.
#+begin_src scheme
  (define (pascal-element level n)
    (cond ((or (= n 0)
               (= n level)) 1)
          (else (+ (pascal-element (1- level)
                                   (1- n))
                   (pascal-element (1- level) n)))))
#+end_src

* Exercise 1.13
#+BEGIN_SRC scheme
  ;; Predefine useful values

  (define *phi* (/ (1+ (sqrt 5)) 2))
  (define *psi* (/ (1- (sqrt 5)) 2))

  ;; Optimized Fibonacci by iteration, copied from the
  ;; book. Seemed like a better way to handle this.
  ;; Protip: don't use the naive implementation to
  ;; calculate fib(60).
  (define (fib-opt-iter a b count)
    (cond ((= count 0) b)
          (else (fib-opt-iter (+ a b) a (1- count)))))

  (define (fib-opt n)
    (fib-opt-iter 1 0 n))


  ;; Instead of writing our own expt function,
  ;; we'll use Scheme's expt

  ;; Fibonacci by approximation.

  ;; NOTE: For some reason, this seems to only work
  ;; for n > 1 (meaning, the first value is never found
  ;; to be 1). Could be an arbitrary computational error,
  ;; but I'll ask around to make sure. Could be a mistake
  ;; of mine.

  (define (fib-approx n)
    (inexact->exact
     (round (/ (- (expt *phi* n)
                  (expt *psi* n))
               (sqrt 5)))))


  ;; Now we try to prove that these two processes
  ;; calculate the same number for as much as you
  ;; want.

  (define (fib-prove-iter count max)
    (if (> count max)
        #t
        (let ((iter-result (fib-opt count))
              (appr-result (fib-approx count)))
          (if (= iter-result appr-result)
              (fib-prove-iter (1+ count) max)
              #f))))

  ;; About this arbitrary 2... look at the note above.
  (define (fib-prove iterations)
    (if (>= iterations 2)
        (fib-prove-iter 2 iterations)))
#+END_SRC

* Exercise 1.14
As the amount of the change grows, the algorithm seems to have both orders of space
and number of steps equal to \theta{}(n²).

Below is a diagram for the expansion of =count-change=.

#+CAPTION: Expansion of the =count-change= function with number 11.
#+NAME:    fig:ex1-14
[[./graphs/ex1-14.png]]

* Exercise 1.15
** a
The procedure =p= is applied five times.
** b
The procedure seems to have both orders of space and number of steps equal
to \theta{}(log(a)).
* Exercise 1.22

#+begin_src scheme
(define (search-for-primes start end)
  (cond ((>= start end) '())
        ((even? start)
         (search-for-primes (1+ start) end))
        (else (begin
                (timed-prime-test start)
                (search-for-primes (+ start 2) end)))))
#+end_src

* Exercise 1.23

#+begin_src scheme
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (define (next divisor)
    (if (= divisor 2) 3 (+ divisor 2)))
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(define (divides? a b)
  (= (remainder b a) 0))
#+end_src

#+begin_src scheme
(map smallest-divisor (cdr (iota 1000)))
#+end_src

* Exercise 1.26

The function computes =(expmod base (/ exp 2) m)= twice for every
squaring operation, which previously only computed this value once and
then squared it. This behaviour increases the complexity of the
function.

* Exercise 1.27

#+begin_src scheme
(define (fermat-test n)
  (fermat-test-iter 1 n))

(define (fermat-test-iter a n) ; a^n cong to a mod n
  (cond ((>= a n) #t)
        ((= (remainder (expt a n) n)
            (remainder a n))
         (fermat-test-iter (1+ a) n))
        (else #f)))
#+end_src

#+begin_src scheme
(map fermat-test '(561 1105 1729 2465 2821 6601))
#+end_src

* Exercise 1.28

#+begin_src scheme
(define (expmod base exp m)
  (define (trivial? value)
    (and (not (= value 1))
         (not (= value (1- m)))
         (= (square value) (remainder 1 m))))
  (define (zero-or-mod value)
    (if (trivial? value)
        0
        (remainder value m)))
  (cond ((= exp 0) 1)
        ((even? exp)
         (zero-or-mod
          (square (expmod base (/ exp 2) m))))
        (else
         (remainder (* base (expmod base (1- exp) m))
                    m))))

(define (miller-rabin-test n)
  (define (try-it a)
    (not (zero? (expmod a (1- n) n))))
  (try-it (1+ (random (1- n)))))
#+end_src

#+begin_src scheme
;; Extras
(define (square x)
  (* x x))

(define (fast-prime-mr? n times)
  (if (not (and (even? n) (> n 2)))
      (cond ((= times 0) #t)
            ((miller-rabin-test n)
             (fast-prime-mr? n (1- times)))
            (else #f))
      #f))

(define (remove-if pred lst)
  (cond ((null? lst) lst)
        ((pred (car lst))
         (remove-if pred (cdr lst)))
        (else (cons (car lst)
                    (remove-if pred (cdr lst))))))
#+end_src

#+begin_src scheme
(let ((num-tests 1000)
      (range     1000))
  (remove-if (lambda (n)
               (or (and (even? n)
                        (> n 2))
                   (not (fast-prime-mr? n num-tests))))
             (cddr (iota range))))
#+end_src

* Exercise 1.29

#+begin_src scheme
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
#+end_src

#+begin_src scheme
(define (simpson-rule f a b n)
  (let ((h (/ (- b a) n)))
    (define (simpson-y k)
      (f (+ a (* k h))))
    (define (simpson-term k)
      (* (+ 2 (* 2 (remainder k 2)))
         (simpson-y k)))
    (* (/ h 3)
       (+ (simpson-y 0)
          (simpson-y n)
          (sum simpson-term 1 1+ (1- n))))))
#+end_src

#+begin_src scheme
(define (cube x)
  (* x x x))

(map (lambda (n)
       (simpson-rule cube 0 1 n))
     '(100 1000))
#+end_src

* Exercise 1.30

#+begin_src scheme
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))
#+end_src

* Exercise 1.31

** a

Linear recursive process

#+begin_src scheme
(define (product term a next b)
  (if (> a b)
      1
      (* (term a)
         (product term (next a) next b))))
#+end_src

Factorial

#+begin_src scheme
(define (factorial n)
  (product (lambda (x) x) 1 1+ n))
#+end_src

Computing π

#+begin_src scheme
(define (compute-pi steps)
  (define (numer-term n)
    (or (and (odd? n) (1+ n))
        (+ n 2)))
  (define (denom-term n)
    (or (and (odd? n) (+ n 2))
        (1+ n)))
  (/ (product numer-term 1 1+ steps)
     (product denom-term 1 1+ steps)
     0.25))
#+end_src

** b

Iterative process

#+begin_src scheme
(define (product term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))
#+end_src

